
[toc]

# 代码检视（Code Review）

代码检视（审查）的目的主要是确保代码库随着时间推移而得到改善。

为实现这一目的，必须平衡一系列的权衡。

- 开发者必须完成能够在他们的任务上取得进展
  - 如果您从未提交过代码库的改进，那么代码库永远不会改进。此外，如果审核人员难以进行任何更改，那么开发人员不会在未来进行改进。
- 代码检视人员确保每个CL都具有质量，随着时间推移，代码库的整体代码健康状况不会降低
  - 这可能很棘手，因为代码库通常会随着时间的推移而降低代码运行状况，特别是当团队受到严重的时间限制并且他们觉得必须采取捷径才能实现目标时。

代码检视中期望的标准：

**一般来说，一旦CL处于一种状态，即使CL不完美，它肯定会提高正在处理的系统的整体代码健康状态，那么它应该倾向于批准CL。**

这是所有代码审查指南中的高级原则。

当然，这有一些限制。例如，如果CL添加了审阅者在其系统中**不需要的功能**，那么即使代码设计良好，审阅者也肯定会拒绝批准。

还有一个关键点：**没有“完美”代码这样的东西 - 只有更好的代码。** 检视人不应要求作者在批准之前对每一小块CL进行润色。相反，审核人员应该平衡进展的必要性。审稿人应该寻求的是持续改进，而不是追求完美。作为一个整体，提高系统的可维护性，可读性和可理解性的CL不应该延迟数天或数周，因为它不是“完美的”。

## 代码检视人员（Reviewer）

## 代码检视要关注的内容

#### 设计

在评论中要涵盖的最重要的事情是CL的整体设计。 CL中各种代码的交互是否有意义？此更改是属于您的代码库还是属于库？它是否与您系统的其他部分很好地集成？现在是添加此功能的好时机吗？

#### 功能

这个CL是否符合开发人员的意图？开发人员对此代码的用户有什么好处？ “用户”通常都是最终用户（当他们受到更改影响时）和开发人员（将来必须“使用”此代码）。

作为检视者，除了功能正常实现外，应该考虑

- 边缘情况，极端值情况，IE兼容性问题
- 并发问题，是否会出现死锁或者竞争条件（通常这类通过简单运行代码是不容易发现的，需要检视人和开发者仔细思考）
- 前端异步请求返回渲染问题
- 针对一些前端ui改动，可以运行起来看效果
等等其他可以考虑的地方

#### 复杂

复杂性要从代码行、函数、类等多个维度去考虑，导致代码复杂度增加常见有以下场景：

- 过度的代码设计（over-engineering）
- 解决当前的问题而不是解决未来的问题

代码的复杂度会直接影响代码的可读性和可维护性，也更容易在变更的时候引入问题。

CL比它应该更复杂吗？在CL的每个级别检查这一点：是否单独一行代码过于复杂？函数太复杂了吗？类太复杂了吗？ “过于复杂”通常意味着 **“代码阅读人员无法快速理解”** 。它也可能意味着 **“开发人员在尝试调用或修改此代码时可能会引入错误。”**

还有一种特殊类型的“复杂性”是 **过度设计** ，即开发人员使代码变得比需要的通用，或者增加了系统目前不需要的功能。检视者应特别 **警惕过度设计** 。鼓励开发人员解决他们现在需要解决的问题，而不是开发人员推测可能需要在未来解决的问题。未来的问题应该在它出现后解决，你可以在物理世界中看到它的具体的情况和需求。

#### 测试

单元测试应当和提交的功能代码在同一个CL中提交；

单元测试本身不会被测试，编写测试用例的人应当保证正确，有意义；

单元测试本身也是代码库中的一部分，所以不要增加测试用例的复杂度。

#### 命名

开发人员是否为所有内容选择了好名字？一个好名字足够长，可以完全传达项目的内容或作用，而不会太长，以至于难以阅读。

#### 注释

**注释应当解释why，而不是说明what。**

开发人员是否用可理解的语言撰写了清晰的注释？所有注释都是必要的吗？

通常，当注释解释为什么存在某些代码时，注释很有用，并且不应该解释某些代码正在做什么。如果代码不够清楚，无法解释自己，那么代码应该变得更简单。有一些例外（正则表达式和复杂算法通常会从解释他们正在做的事情的评论中获益很多），但大多数评论都是针对代码本身不可能包含的信息，例如决策背后的推理。

查看此CL之前的注释也很有帮助。也许有一个TODO现在可以删除，一个评论建议不要进行这种改变，等等。

请注意，注释与类，模块或函数的文档不同，它们应该代表一段代码的目的，如何使用它，以及它在使用时的行为方式。

#### 代码风格

遵循代码风格，代码风格的重构和功能CL应该拆分提交，先重构风格，再提交功能CL。

对代码变更的每一行做检视，同时要结合代码的上下文（Context）而不只是工具展示出来的变更部分，这样才能判断出增加了几行，是否应该把一个超过50行的函数拆分成更小的函数。另外的建议除了聚焦错误，对好的代码应该赞赏developer，尤其是将commets修改后的好代码。

#### 文档

如果CL更改了用户构建，测试，交互或发布代码的方式，请检查它是否还更新了相关文档，包括README，g3doc页面和任何生成的参考文档。如果CL删除或弃用代码，请考虑是否也应删除文档。如果缺少文档，请询问。

#### 每一行

查看您已分配审核的每行代码。有些东西，比如数据文件，生成的代码或大型数据结构，你有时可以扫描，但不扫描人类编写的类，函数或代码块，并假设它内部的内容是可以的。显然，某些代码需要比其他代码更仔细的审查 - 这是你必须做出的判断调用 - 但你至少应该确定你理解所有代码正在做什么。

如果您阅读代码太难了，这会减慢审核速度，那么您应该让开发人员知道并等待他们在您尝试审核之前澄清它。在谷歌，我们聘请了优秀的软件工程师，你就是其中之一。如果您无法理解代码，那么很可能其他开发人员也不会。因此，当您要求开发人员澄清此代码时，您也会帮助未来的开发人员理解这些代码。

如果您了解代码但是您觉得没有资格进行某些部分的审核，请确保CL上有一个合格的审核人，特别是对于安全性，并发性，可访问性，国际化等复杂问题。

#### 上下文

在广泛的背景下查看CL通常很有帮助。通常，代码审查工具只会显示围绕要更改的部分的几行代码。有时您必须查看整个文件以确保更改确实有意义。例如，您可能只看到添加了四个新行，但是当您查看整个文件时，您会看到这四行是50行方法，现在确实需要分解为更小的方法。

在整个系统的上下文中考虑CL也很有用。这个CL是否改善了系统的代码健康状况，还是使整个系统更复杂，测试更少等等？不接受降低系统代码运行状况的CL。大多数系统通过许多小的变化而变得复杂，因此在新变化中防止甚至很小的复杂性也很重要。

#### 好东西

如果你在CL中看到一些不错的东西，请告诉开发人员，特别是当他们以一种很好的方式解决你的一条评论时。代码审查通常只关注错误，但它们也应该为良好实践提供鼓励和欣赏。在指导方面，有时甚至更有价值的是告诉开发人员他们做得对，而不是告诉他们他们做错了什么。

#### 摘要

在进行代码审查时，您应该确保：

- 代码设计精良。
- 该功能对代码的用户有利。
- 任何UI更改都是明智的，看起来很好。
- 任何并行编程都是安全的。
- 代码并不比它需要的更复杂。
- 开发人员没有实现他们将来可能需要的东西，但现在还不知道他们需要的东西。
- 代码有适当的单元测试。
- 测试精心设计。
- 开发人员使用了清晰的名称。
- 注释是清楚和有用的，并且大多解释为什么而不是什么。
- 代码已适当记录（通常在g3doc中）。
- 代码符合我们的风格指南。

确保查看您被要求查看的每一行代码，查看上下文，确保您提高代码运行状况，并赞扬开发人员所做的好事。


### 检视的速度

当代码检视进行的很慢时，可能发生了：
1、整个团队的效率下降了；
2、开发人员开始抗议代码检视（day级的响应并打回CL，导致开发人员的抱怨）
3、代码质量下降。

#### 代码检视应该多快

收到代码检视申请应该立刻响应，最长不超过一个工作日（通常是在第二个工作日的早晨）

#### 如何处理打断

如果在集中精力处理一项任务或者在编码，就不要让code review打断自己，否则会需要小号更多的精力恢复原先的工作。建议在当前工作完成、开完会议、吃午饭回来、早晨刚到工位等时间进行检视。

#### 快速的响应

即使CL很大，或者你没有时间进行代码检视，也尽量尽快的响应，并给初步给出一个整体的意见。

#### 正向循环
长期坚持代码检视的原则，可以让开发者意识到好代码的要求，代码检视的速度也会越来越快，但是一定不能通过让步代码检视标准来提高检视速度。


## 开发者（Developer）

### 写出好的CL描述
CL描述是对正在进行的更改及其制作原因的公开记录。它将成为我们版本控制历史的永久部分，并且多年来可能会被除审阅者之外的数百人阅读。

未来的开发人员将根据其描述搜索您的CL。未来的某个人可能正在寻找你的改变，因为它的相关性有微弱的记忆，但没有方便的细节。如果所有重要信息都在代码而不是描述中，那么他们找到你的CL会更加困难。

#### 第一行
- 正在做什么的简短摘要。
- 完整的句子，写成好像是订单。
- 跟着空行。

CL描述的第一行应该是CL的具体内容的简短摘要，后面是一个空行。这是大多数未来的代码搜索者在浏览一段代码的版本控制历史时会看到的内容，因此第一行应该足够提供信息，以便他们不必阅读您的CL或其整个描述只是为了获得一般性你的CL实际上做了什么的想法。

按照传统，CL描述的第一行是一个完整的句子，就好像它是一个命令（一个命令句）。例如，说“Delete the FizzBuzz RPC and replace it with the new system.”。而不是“Deleting the FizzBuzz RPC and replacing it with the new system.”。但是，您不必将其余描述写为命令式句子。

#### 内容是提供信息的
其余描述应该是提供信息的。它可能包括对正在解决的问题的简要描述，以及为什么这是最好的方法。如果方法有任何缺点，应该提到它们。如果相关，请包括背景信息，例如错误编号，基准测试结果以及设计文档的链接。

即使是小型CL也需要注意细节。把CL放在上下文中。

#### Bad CL描述
“修复bug”是一个不充分的CL描述。什么bug？你做了什么修复它？其他类似的不良描述包括：

- “修复构建。”
- “添加补丁。”
- “将代码从A移动到B.”
- “阶段1。”
- “添加便利功能。”
- “kill奇怪的网址。”

其中一些是真正的CL描述。他们的作者可能认为他们提供了有用的信息，但他们没有达到CL描述的目的。

#### Good CL描述
以下是一些很好的描述示例。

###### 功能改变
> rpc：删除RPC服务器消息freelist上的大小限制。
> 
> 像FizzBuzz这样的服务器有非常大的消息，并且可以从重用中受益。使freelist更大，并添加一个goroutine，随着时间的推移缓慢释放freelist条目，以便空闲服务器最终释放所有freelist条目。

前几个词描述了CL实际上做了什么。其余的描述讨论了正在解决的问题，为什么这是一个很好的解决方案，以及有关具体实现的更多信息。

##### 重构
> 使用TimeKeeper构造任务以使用其TimeStr和Now方法。
> 
> 向Task添加一个Now方法，这样就可以删除borglet() getter方法（只有OOMCandidate用它来调用borglet的Now方法）。这取代了委托给TimeKeeper的Borglet上的方法。
> 
> 允许任务提供现在是消除对Borglet的依赖的一个步骤。最终，依赖于从任务中获取Now的协作者应该被更改为直接使用TimeKeeper，但这可以通过小步骤进行重构。
> 
> 继续重构Borglet层次结构的长期目标。

第一行描述了CL的作用以及这是如何改变过去的。其余的描述讨论了具体的实现，CL的背景，解决方案并不理想，以及可能的未来方向。它还解释了为什么要做出这种改变。

##### 小CL需要一些上下文
> 为status.py创建Python3构建规则。
> 
> 这允许已经在Python3中使用它的消费者依赖于原始状态构建规则旁边的规则而不是它们自己的树中的某个地方。它鼓励新的消费者使用Python3而不是Python2，并且显着简化了当前正在使用的一些自动构建文件重构工具。

第一句话描述了实际做了什么。其余的描述解释了为什么要进行更改并为审阅者提供了大量背景信息。


### 小的CL

#### 为什么要写小CL？

小而简单的CL是：

- **评论更快。** 审阅者更容易找到五次分钟来审查小型CL，而不是留出30分钟的时间来审查一个大型CL。
- **评论更彻底。** 随着大的变化，审稿人和作者往往会因为大量详细的评论来回变换而感到沮丧 - 有时甚至到了重要点被遗漏或丢失的程度。
- **不太可能引入错误。** 由于您进行的更改较少，因此您和您的审阅者可以更轻松地有效地推断CL的影响，并查看是否已引入错误。
- **如果被拒绝，减少浪费的工作。** 如果你写了一个巨大的CL然后你的评论者说整体方向是错误的，你就浪费了很多工作。
- **更容易合并。** 处理大型CL需要很长时间，因此在合并时会出现很多冲突，并且必须经常合并。
- **设计更容易。** 抛光一个小变化的设计和代码健康状况比完善一个大变化的所有细节要容易得多。
- **减少对评论的阻碍。** 发送整体更改的自包含部分可让您在等待当前CL审核时继续编码。
- **更简单的回滚。** 大型CL更有可能触及在初始CL提交和回滚CL之间更新的文件，从而使回滚变得复杂（中间的CL也可能需要回滚）。
请注意，**审稿人可以自行决定完全拒绝您的更改，原因只是因为它太大。** 通常他们会感谢您的贡献，但要求您以某种方式将其变为一系列较小的变化。在您编写完变更后，或者需要花费大量时间来讨论为什么审阅者应该接受您的大变更，这可能需要做很多工作。首先编写小型CL更容易。

#### 什么是小？

一般来说，CL的正确大小是一个独立的变化。这意味着：

- CL进行了一项最小的更改，只解决了一件事。这通常只是功能的一部分，而不是一次完整的功能。一般来说，最好是在编写过小的CL而不是过大的CL时犯错误。与您的审阅者合作，找出可接受的大小。
- 审阅者需要了解的关于CL的所有内容（除了未来的开发）都在CL，CL的描述，现有的代码库或他们已经审查过的CL中。
- 在签入CL后，系统将继续为其用户和开发人员提供良好的工作。
- CL不是那么小，其含义难以理解。如果您添加新API，则应在同一CL中包含API的使用，以便审阅者可以更好地了解API的使用方式。这也可以防止检查未使用的API。
关于有多大“太大”没有严格的规则。对于CL来说，100行通常是合理的大小，1000行通常太大，但这取决于您的评论者的判断。更改分散的文件数也会影响其“大小”。一个文件中的200行更改可能没问题，但是分布在50个文件中通常会太大。

请记住，尽管从开始编写代码开始就已经密切参与了代码，但审阅者通常没有上下文。对你来说，看起来像是一个可接受的大小的CL对你的评论家来说可能是压倒性的。如有疑问，请编写比您认为需要编写的小的CL。审稿人很少抱怨获得太小的CL。

#### 什么时候大CL好？
在某些情况下，大的变化并不那么糟糕：

- 文件的删除和迁移、重命名，不涉及改动只是整个文件的调整，单独CL
- 自动生成的bean、dao、xml文件，可以先提交

#### 按文件拆分
- 有时，您完全信任的自动重构工具生成了大型CL，审阅者的工作只是进行健全性检查，并说他们确实想要进行更改。尽管上面的一些警告（例如合并和测试）仍然适用，但这些CL可能更大。
拆分CL的另一种方法是对文件进行分组，这些文件需要不同的审阅者，否则就是自包含的更改。

例如：您发送一个CL以修改协议缓冲区，另一个CL发送更改使用该原型的代码。您必须在代码CL之前提交proto CL，但它们都可以同时进行查看。如果这样做，您可能希望通知两组审阅者您编写的其他CL，以便他们具有您的更改的上下文。

另一个例子：你发送一个CL用于代码更改，另一个用于使用该代码的配置或实验;如果需要，这也更容易回滚，因为配置/实验文件有时会比代码更改更快地推向生产。

#### 分离出重构
通常最好在功能更改或错误修复的单独CL中进行重构。例如，移动和重命名类应该与修复该类中的错误的CL不同。审阅者更容易理解每个CL在单独时引入的更改。

但是，修复本地变量名称等小清理可以包含在功能更改或错误修复CL中。这取决于开发人员和审核人员的判断，以确定重构何时如此大，以至于如果包含在您当前的CL中，将使审核更加困难。

#### 将相关的测试代码保存在同一个CL中
避免将测试代码拆分为单独的CL。验证代码修改的测试应该进入相同的CL，即使它增加了代码行数。

但是，独立的测试修改可以首先进入单独的CL，类似于重构指南。那包括：

- 使用新测试验证预先存在的已提交代码。
- 重构测试代码（例如引入辅助函数）。
- 引入更大的测试框架代码（例如集成测试）。

#### 不要破坏构建
如果你有几个相互依赖的CL，你需要找到一种方法来确保在提交每个CL后整个系统继续工作。否则，您可能会在CL提交之间的几分钟内破坏所有开发人员的构建（如果您的后续CL提交出现意外情况，则可能更长）。

#### 不能让它足够小
有时您会遇到CL似乎必须很大的情况。这很少是真的。练习编写小型CL的作者几乎总能找到将功能分解为一系列小改动的方法。

在编写大型CL之前，请考虑在重构CL之前是否可以为更清晰的实现铺平道路。与你的队友交谈，看看是否有人想过如何在小型CL中实现这些功能。

如果所有这些选项都失败了（这应该是非常罕见的），那么请事先征得审核人员的同意，以便审核大型CL，以便他们收到有关即将发生的事情的警告。在这种情况下，期望在很长一段时间内完成审核过程，对不引入错误保持警惕，并且在编写测试时要特别勤奋。
