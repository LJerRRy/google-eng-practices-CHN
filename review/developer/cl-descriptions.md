# 写出好的CL描述
CL描述是对正在进行的更改及其制作原因的公开记录。它将成为我们版本控制历史的永久部分，并且多年来可能会被除审阅者之外的数百人阅读。

未来的开发人员将根据其描述搜索您的CL。未来的某个人可能正在寻找你的改变，因为它的相关性有微弱的记忆，但没有方便的细节。如果所有重要信息都在代码而不是描述中，那么他们找到你的CL会更加困难。

## 第一行
- 正在做什么的简短摘要。
- 完整的句子，写成好像是订单。
- 跟着空行。

CL描述的第一行应该是CL的具体内容的简短摘要，后面是一个空行。这是大多数未来的代码搜索者在浏览一段代码的版本控制历史时会看到的内容，因此第一行应该足够提供信息，以便他们不必阅读您的CL或其整个描述只是为了获得一般性你的CL实际上做了什么的想法。

按照传统，CL描述的第一行是一个完整的句子，就好像它是一个命令（一个命令句）。例如，说“Delete the FizzBuzz RPC and replace it with the new system.”。而不是“Deleting the FizzBuzz RPC and replacing it with the new system.”。但是，您不必将其余描述写为命令式句子。

## 内容是提供信息的
其余描述应该是提供信息的。它可能包括对正在解决的问题的简要描述，以及为什么这是最好的方法。如果方法有任何缺点，应该提到它们。如果相关，请包括背景信息，例如错误编号，基准测试结果以及设计文档的链接。

即使是小型CL也需要注意细节。把CL放在上下文中。

## Bad CL描述
“修复bug”是一个不充分的CL描述。什么bug？你做了什么修复它？其他类似的不良描述包括：

- “修复构建。”
- “添加补丁。”
- “将代码从A移动到B.”
- “阶段1。”
- “添加便利功能。”
- “kill奇怪的网址。”

其中一些是真正的CL描述。他们的作者可能认为他们提供了有用的信息，但他们没有达到CL描述的目的。

## Good CL描述
以下是一些很好的描述示例。

### 功能改变
> rpc：删除RPC服务器消息freelist上的大小限制。
> 
> 像FizzBuzz这样的服务器有非常大的消息，并且可以从重用中受益。使freelist更大，并添加一个goroutine，随着时间的推移缓慢释放freelist条目，以便空闲服务器最终释放所有freelist条目。

前几个词描述了CL实际上做了什么。其余的描述讨论了正在解决的问题，为什么这是一个很好的解决方案，以及有关具体实现的更多信息。

### 重构
> 使用TimeKeeper构造任务以使用其TimeStr和Now方法。
> 
> 向Task添加一个Now方法，这样就可以删除borglet() getter方法（只有OOMCandidate用它来调用borglet的Now方法）。这取代了委托给TimeKeeper的Borglet上的方法。
> 
> 允许任务提供现在是消除对Borglet的依赖的一个步骤。最终，依赖于从任务中获取Now的协作者应该被更改为直接使用TimeKeeper，但这可以通过小步骤进行重构。
> 
> 继续重构Borglet层次结构的长期目标。

第一行描述了CL的作用以及这是如何改变过去的。其余的描述讨论了具体的实现，CL的背景，解决方案并不理想，以及可能的未来方向。它还解释了为什么要做出这种改变。

### 小CL需要一些上下文
> 为status.py创建Python3构建规则。
> 
> 这允许已经在Python3中使用它的消费者依赖于原始状态构建规则旁边的规则而不是它们自己的树中的某个地方。它鼓励新的消费者使用Python3而不是Python2，并且显着简化了当前正在使用的一些自动构建文件重构工具。

第一句话描述了实际做了什么。其余的描述解释了为什么要进行更改并为审阅者提供了大量背景信息。

## 在提交CL之前查看说明
CL在审核期间可能会发生重大变化。在提交CL之前检查CL描述是值得的，以确保描述仍然反映了CL的作用。

下一篇：[小型CL]()
